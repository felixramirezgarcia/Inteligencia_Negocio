<?xml version="1.0" encoding="UTF-8"?>
<config xmlns="http://www.knime.org/2008/09/XMLConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.knime.org/2008/09/XMLConfig http://www.knime.org/XMLConfig_2008_09.xsd" key="viewRepresentation">
<entry key="jsNamespace" type="xstring" value="streamgraph_namespace"/>
<config key="jsCode">
<entry key="array-size" type="xint" value="1"/>
<entry key="0" type="xstring" value="(streamgraph_namespace = function () {%%00010%%00010  var view = {};%%00010  var _representation, _value;%%00010  var _data;%%00010  var _colorRange;%%00010  var layoutContainer;%%00010  var MIN_HEIGHT = 300, MIN_WIDTH = 400;%%00010  var chart, svg;%%00010  var knimeTable1, knimeTable2;%%00010  var xAxisType, xAxisData;%%00010  var currentFilter = null;%%00010%%00010  var stackStyleByType = {%%00010    &quot;Stacked-Area-Chart&quot;: &quot;stack&quot;,%%00010    &quot;Percentage-Area-Chart&quot;: &quot;expand&quot;,%%00010    &quot;Stream-Graph&quot;: &quot;stream-center&quot;%%00010  }%%00010%%00010  var TOOLTIP_WARNING = 'basisTooltip';%%00010%%00010%%00010  view.init = function (representation, value) {%%00010    _representation = representation;%%00010    _value = value;%%00010    // Create Knime tables from data.%%00010    // Load data from port 1.%%00010    knimeTable1 = new kt();%%00010    knimeTable1.setDataTable(_representation.inObjects[0]);%%00010    var columnKeys = _representation.options.columns;%%00010%%00010    // Load data from port 2.%%00010    knimeTable2 = null;%%00010    if (_representation.inObjects[1] !== null) {%%00010      knimeTable2 = new kt();%%00010      knimeTable2.setDataTable(_representation.inObjects[1]);%%00010    }%%00010%%00010    // Set locale for moment.js.%%00010    if (_representation.options.dateTimeFormats.globalDateTimeLocale !== 'en') {%%00010      moment.locale(_representation.options.dateTimeFormats.globalDateTimeLocale);%%00010    }%%00010%%00010%%00010    if (_representation.options.enableViewControls) {%%00010      drawControls();%%00010    }%%00010    setColors();%%00010    setXAxisConf();%%00010    transformData();%%00010    drawChart();%%00010    toggleFilter();%%00010  }%%00010%%00010  var drawChart = function () {%%00010    // Remove earlier chart.%%00010    d3.select(&quot;#layoutContainer&quot;).remove();%%00010%%00010    /*%%00010     * Parse some options.%%00010     */%%00010    var stackStyle = stackStyleByType[_value.options.chartType];%%00010    var optFullscreen = _representation.options.svg.fullscreen &amp;&amp;%%00010      _representation.runningInView;%%00010    var isTitle = _value.options.title !== &quot;&quot; || _value.options.subtitle !== &quot;&quot;;%%00010%%00010    /*%%00010     * Create HTML for the view.%%00010     */%%00010    var body = d3.select(&quot;body&quot;);%%00010%%00010    // Determine available witdh and height.%%00010    if (optFullscreen) {%%00010      var width = &quot;100%&quot;;%%00010%%00010      if (isTitle || !_representation.options.enableViewControls) {%%00010        knimeService.floatingHeader(true);%%00010        var height = &quot;100%&quot;;%%00010      } else {%%00010        knimeService.floatingHeader(false);%%00010        var height = &quot;calc(100% - &quot; + knimeService.headerHeight() + &quot;px)&quot;%%00010      }%%00010%%00010    } else {%%00010      var width = _representation.options.svg.width + 'px';%%00010      var height = _representation.options.svg.height + 'px';%%00010    }%%00010%%00010    layoutContainer = body.append(&quot;div&quot;)%%00010      .attr(&quot;id&quot;, &quot;layoutContainer&quot;)%%00010      .attr('class', 'knime-layout-container')%%00010      .style({%%00010        &quot;width&quot;: width,%%00010        &quot;height&quot;: height,%%00010        &quot;min-width&quot;: MIN_WIDTH + &quot;px&quot;,%%00010        &quot;min-height&quot;: MIN_HEIGHT + &quot;px&quot;,%%00010        &quot;position&quot;: &quot;absolute&quot;%%00010      });%%00010%%00010    // create div container to hold svg%%00010    var svgContainer = layoutContainer.append(&quot;div&quot;)%%00010      .attr(&quot;id&quot;, &quot;svgContainer&quot;)%%00010      .attr('class', 'knime-svg-container')%%00010      .style({%%00010        &quot;min-width&quot;: MIN_WIDTH + &quot;px&quot;,%%00010        &quot;min-height&quot;: MIN_HEIGHT + &quot;px&quot;,        %%00010        &quot;width&quot;: &quot;100%&quot;,%%00010        &quot;height&quot;: &quot;100%&quot;%%00010      });%%00010%%00010    // Create the SVG object%%00010    svg = svgContainer.append(&quot;svg&quot;)%%00010      .attr(&quot;id&quot;, &quot;svg&quot;);%%00010%%00010    if (optFullscreen) {%%00010      svg.attr(&quot;width&quot;, &quot;100%&quot;);%%00010      svg.attr(&quot;height&quot;, &quot;100%&quot;);%%00010    } else {%%00010      svg.attr(&quot;width&quot;, width)%%00010      svg.attr(&quot;height&quot;, height);%%00010    }%%00010%%00010    if (_value.options.interpolation == 'basis' &amp;&amp; _value.options.interactiveGuideline) {%%00010      knimeService.setWarningMessage('Displaying a tooltip is not supported when interpolation is set to &quot;basis&quot;.', TOOLTIP_WARNING);%%00010    } else {%%00010      knimeService.clearWarningMessage(TOOLTIP_WARNING);%%00010    }%%00010%%00010    // create the stacked area chart%%00010    nv.addGraph(function () {%%00010      chart = nv.models.stackedAreaChart()%%00010        .margin({ right: 50 })%%00010        .x(function (d) { return d[0]; })%%00010        .y(function (d) { return d[1]; })%%00010        .color(_colorRange)%%00010        .interpolate(_value.options.interpolation)%%00010        .style(stackStyle)%%00010        .showControls(false)%%00010        .showLegend(true)%%00010        .useInteractiveGuideline(_value.options.interpolation == 'basis' ? false : _value.options.interactiveGuideline)%%00010        .interactive(false)%%00010        .duration(0);%%00010%%00010      chart.dispatch.on('renderEnd.css', setCssClasses);      %%00010%%00010      var topMargin = 10;%%00010      topMargin += _value.options.title ? 10 : 0;%%00010      topMargin += _value.options.legend ? 0 : 30;%%00010      topMargin += _value.options.subtitle ? 8 : 0;%%00010      var bottomMargin = _value.options.title || _value.options.subtitle ? 25 : 30;%%00010      chart.legend.margin({%%00010        top: topMargin,%%00010        bottom: topMargin%%00010      });%%00010      chart.margin({%%00010        top: topMargin,%%00010        bottom: bottomMargin%%00010      });%%00010%%00010      chart.xAxis%%00010        .tickFormat(createXAxisFormatter());%%00010%%00010      chart.yAxis%%00010        .tickFormat(d3.format(_representation.options.yAxisFormatString));%%00010%%00010      updateTitles(false);%%00010      updateAxisLabels(false);%%00010%%00010      svg.datum(_data).call(chart);%%00010%%00010      nv.utils.windowResize(chart.update);%%00010%%00010      if (&quot;disabled&quot; in _value.options) {%%00010        var state = chart.defaultState();%%00010        state.disabled = _value.options.disabled;%%00010        chart.dispatch.changeState(state);%%00010      }%%00010%%00010      toggleGrid();%%00010      toggleLegend();%%00010%%00010      // tooltip is re-created every time therefore we need to assign classes accordingly%%00010      chart.interactiveLayer.dispatch.on('elementMousemove.tooltipCss', setTooltipCssClasses);%%00010%%00010      return chart;%%00010    });%%00010  }%%00010%%00010  var toggleGrid = function () {%%00010    var opacity = _value.options.showGrid ? 1 : 0;%%00010    d3.selectAll(&quot;g.tick:not(.zero) &gt; line&quot;).style(&quot;opacity&quot;, opacity);%%00010  }%%00010%%00010  var toggleLegend = function () {%%00010    var opacity = _value.options.legend ? 1 : 0;%%00010    d3.select(&quot;g.nv-legend&quot;).style(&quot;opacity&quot;, opacity);%%00010  }%%00010%%00010  var setXAxisConf = function () {%%00010    // Set data and data type for the x-axis.%%00010    var xAxisColumn = _representation.options.xAxisColumn;%%00010    if (typeof xAxisColumn !== &quot;undefined&quot;) {%%00010      var columnIndex = knimeTable1.getColumnNames().indexOf(xAxisColumn);%%00010      xAxisType = knimeTable1.getColumnTypes()[columnIndex];%%00010      if (xAxisType == &quot;dateTime&quot;) {%%00010        // need to get which exactly date&amp;time type it is%%00010        xAxisType = knimeTable1.getKnimeColumnTypes()[columnIndex];%%00010      }%%00010      xAxisData = knimeTable1.getColumn(columnIndex);%%00010    } else {%%00010      // If undefined: The user selected RowId as x-Axis.%%00010      xAxisType = &quot;string&quot;;%%00010      xAxisData = [];%%00010%%00010      var rows = knimeTable1.getRows();%%00010      for (var i = 0; i &lt; rows.length; i++) {%%00010        xAxisData.push(rows[i].rowKey);%%00010      }%%00010    }%%00010  }%%00010%%00010  // Transform the tabular format into a JSON format.%%00010  var transformData = function () {%%00010    // Check which rows are included by the filter.%%00010    var includedRows = [];%%00010    for (var i = 0; i &lt; knimeTable1.getNumRows(); i++) {%%00010      if (!currentFilter ||%%00010        knimeTable1.isRowIncludedInFilter(i, currentFilter)) {%%00010%%00010        includedRows.push(i);%%00010      }%%00010    }%%00010%%00010    _data = [];%%00010    var columns = _representation.options.columns%%00010    // Loop over all columns.%%00010    for (var i = 0; i &lt; columns.length; i++) {%%00010      var columnKey = columns[i];%%00010      var columnIndex = knimeTable1.getColumnNames().indexOf(columnKey);%%00010      var currentColumn = knimeTable1.getColumn(columnIndex);%%00010%%00010      _data.push({%%00010        &quot;key&quot;: columnKey,%%00010        &quot;values&quot;: includedRows.map(%%00010          // This loops over all rows that are included.%%00010          function (i) {%%00010            d = currentColumn[i];%%00010%%00010            if (xAxisType === 'number') {%%00010              // If data type of x-axis column can be interpreted as numeric,%%00010              // use the data for the x-axis.%%00010              return [xAxisData[i], d]%%00010            } else {%%00010              // If not, just use an integer index [0, n[.%%00010              return [i, d];%%00010            }%%00010          }%%00010        )%%00010      });%%00010    }%%00010  };%%00010%%00010  var toggleFilter = function () {%%00010    if (_value.options.subscribeFilter) {%%00010      knimeService.subscribeToFilter(%%00010        _representation.tableIds[0], filterChanged, knimeTable1.getFilterIds()%%00010      );%%00010    } else {%%00010      knimeService.unsubscribeFilter(_representation.tableIds[0], filterChanged);%%00010    }%%00010  }%%00010%%00010  var filterChanged = function (filter) {%%00010    currentFilter = filter;%%00010    transformData();%%00010    svg.datum(_data);%%00010    chart.update();%%00010  }%%00010%%00010  // Set color scale: custom or default.%%00010  var setColors = function () {%%00010    var colorScale = [];%%00010    var columns = _representation.options.columns;%%00010    if (knimeTable2 !== null) {%%00010      var rowColors = knimeTable2.getRowColors();%%00010      var numColumns = columns.length;%%00010      for (var i = 0; i &lt; numColumns; i++) {%%00010        var columnName = columns[i]%%00010        var rowIndex = knimeTable1.getColumnNames().indexOf(columnName);%%00010        var color = rowColors[rowIndex];%%00010%%00010        if (!color) {%%00010          color = &quot;#7C7C7C&quot;;%%00010        }%%00010        colorScale.push(color);%%00010      }%%00010      _colorRange = colorScale;%%00010    } else {%%00010      colorScale = d3.scale.category10();%%00010      if (columns.length &gt; 10) {%%00010        colorScale = d3.scale.category20();%%00010      }%%00010      _colorRange = colorScale.range();%%00010    }%%00010  }%%00010%%00010  // Return a function to format the x-axis-ticks.%%00010  var createXAxisFormatter = function () {%%00010    switch (xAxisType) {%%00010      case &quot;Date and Time&quot;:%%00010        return function (i) {%%00010          return moment(xAxisData[i]).utc().format(_representation.options.dateTimeFormats.globalDateTimeFormat);%%00010        };%%00010      case &quot;Local Date&quot;:%%00010        return function (i) {%%00010          return moment(xAxisData[i]).format(_representation.options.dateTimeFormats.globalLocalDateFormat);%%00010        };%%00010      case &quot;Local Date Time&quot;:%%00010        return function (i) {%%00010          return moment(xAxisData[i]).format(_representation.options.dateTimeFormats.globalLocalDateTimeFormat);%%00010        };%%00010      case &quot;Local Time&quot;:%%00010        return function (i) {%%00010          return moment(xAxisData[i], &quot;hh:mm:ss.SSSSSSSSS&quot;).format(_representation.options.dateTimeFormats.globalLocalTimeFormat);%%00010        };%%00010      case &quot;Zoned Date Time&quot;:%%00010        return function (i) {%%00010          var data = xAxisData[i];%%00010          var regex = /(.*)\[(.*)\]$/%%00010          var match = regex.exec(data);%%00010%%00010          if (match == null) {%%00010            var date = moment.tz(data, &quot;&quot;);%%00010          } else {%%00010            dateTimeOffset = match[1];%%00010            var date = moment.tz(dateTimeOffset, _representation.options.dateTimeFormats.timezone);%%00010          }%%00010%%00010          return date.format(_representation.options.dateTimeFormats.globalZonedDateTimeFormat);%%00010        };%%00010      case &quot;string&quot;:%%00010        return function (i) { return xAxisData[i]; };%%00010      case &quot;number&quot;:%%00010        return d3.format(_representation.options.xAxisFormatString);%%00010      default:%%00010        return function (i) { return i; };%%00010    }%%00010  }%%00010%%00010  var updateTitles = function (updateChart) {%%00010    if (chart) {%%00010      var curTitle = d3.select(&quot;#title&quot;);%%00010      var curSubtitle = d3.select(&quot;#subtitle&quot;);%%00010      var chartNeedsUpdating = curTitle.empty() != !(_value.options.title)%%00010        || curSubtitle.empty() != !(_value.options.subtitle);%%00010      if (!_value.options.title) {%%00010        curTitle.remove();%%00010      }%%00010      if (_value.options.title) {%%00010        if (curTitle.empty()) {%%00010          svg.append(&quot;text&quot;)%%00010            .attr(&quot;x&quot;, 20)%%00010            .attr(&quot;y&quot;, 30)%%00010            .attr(&quot;id&quot;, &quot;title&quot;)%%00010            .attr('class', 'knime-title')%%00010            .text(_value.options.title);%%00010        } else {%%00010          curTitle.text(_value.options.title);%%00010        }%%00010      }%%00010      if (!_value.options.subtitle) {%%00010        curSubtitle.remove();%%00010      }%%00010      if (_value.options.subtitle) {%%00010        if (curSubtitle.empty()) {%%00010          svg.append(&quot;text&quot;)%%00010            .attr(&quot;x&quot;, 20)%%00010            .attr(&quot;y&quot;, _value.options.title ? 46 : 20)%%00010            .attr(&quot;id&quot;, &quot;subtitle&quot;)%%00010            .attr('class', 'knime-subtitle')%%00010            .text(_value.options.subtitle);%%00010        } else {%%00010          curSubtitle.text(_value.options.subtitle)%%00010            .attr(&quot;y&quot;, _value.options.title ? 46 : 20);%%00010        }%%00010      }%%00010%%00010      if (updateChart &amp;&amp; chartNeedsUpdating) {%%00010        var topMargin = 10;%%00010        topMargin += _value.options.title ? 10 : 0;%%00010        topMargin += _value.options.legend ? 0 : 30;%%00010        topMargin += _value.options.subtitle ? 8 : 0;%%00010        var bottomMargin = 25;%%00010        bottomMargin += !(_value.options.title || _value.options.subtitle) ? 5 : 0;%%00010        bottomMargin += _value.options.xAxisLabel ? 20 : 0;%%00010        chart.legend.margin({%%00010          top: topMargin,%%00010          bottom: topMargin%%00010        });%%00010        chart.margin({%%00010          top: topMargin,%%00010          bottom: bottomMargin%%00010        });%%00010%%00010        if (_representation.options.svg.fullscreen%%00010          &amp;&amp; _representation.runningInView) {%%00010%%00010          var isTitle = _value.options.title !== &quot;&quot; || _value.options.subtitle !== &quot;&quot;;%%00010%%00010          if (isTitle || !_representation.options.enableViewControls) {%%00010            knimeService.floatingHeader(true);%%00010            var height = &quot;100%&quot;;%%00010          } else {%%00010            knimeService.floatingHeader(false);%%00010            var height = &quot;calc(100% - &quot; + knimeService.headerHeight() + &quot;px)&quot;%%00010          }%%00010%%00010          layoutContainer.style(&quot;height&quot;, height)%%00010            // two rows below force to invalidate the container which solves a weird problem with vertical scroll bar in IE%%00010            .style('display', 'none').style('display', 'block');%%00010          // d3.select(&quot;#svgContainer&quot;).style(&quot;height&quot;, height);%%00010        }%%00010%%00010        chart.update();%%00010      }%%00010    }%%00010  }%%00010%%00010  function updateAxisLabels(updateChart) {%%00010    if (chart) {%%00010      var curYAxisLabel = &quot;&quot;;%%00010      var curXAxisLabel = &quot;&quot;;%%00010      var curYAxisLabelElement = d3.select(&quot;.nv-y.nv-axis .nv-axislabel&quot;);%%00010      var curXAxisLabelElement = d3.select(&quot;.nv-x.nv-axis .nv-axislabel&quot;);%%00010      if (!curYAxisLabelElement.empty()) {%%00010        curYAxisLabel = curYAxisLabelElement.text();%%00010      }%%00010      if (!curXAxisLabelElement.empty()) {%%00010        curXAxisLabel = curXAxisLabelElement.text();%%00010      }%%00010      var chartNeedsUpdating = (curYAxisLabel != _value.options.yAxisLabel)%%00010        || (curXAxisLabel != _value.options.xAxisLabel);%%00010%%00010      if (!chartNeedsUpdating) return;%%00010%%00010      chart.xAxis%%00010        .axisLabel(_value.options.xAxisLabel)%%00010        .axisLabelDistance(0);%%00010%%00010      chart.yAxis%%00010        .axisLabel(_value.options.yAxisLabel)%%00010        .axisLabelDistance(0)%%00010%%00010      var bottomMargin = 25;%%00010      bottomMargin += !(_value.options.title || _value.options.subtitle) ? 5 : 0;%%00010      bottomMargin += _value.options.xAxisLabel ? 20 : 0;%%00010%%00010      var leftMargin = 60;%%00010      leftMargin += _value.options.yAxisLabel ? 15 : 0;%%00010%%00010      chart.margin({ left: leftMargin, bottom: bottomMargin })%%00010%%00010      if (updateChart) {%%00010        chart.update();%%00010      }%%00010    }%%00010  }%%00010%%00010  var drawControls = function () {%%00010    if (!knimeService) {%%00010      // TODO: error handling?%%00010      return;%%00010    }%%00010%%00010    if (_representation.options.displayFullscreenButton) {%%00010      knimeService.allowFullscreen();%%00010    }%%00010%%00010    if (!_representation.options.enableViewControls) {%%00010      return;%%00010    }%%00010%%00010    // Title / Subtitle Configuration%%00010    var titleEdit = _representation.options.enableTitleEdit;%%00010    var subtitleEdit = _representation.options.enableSubtitleEdit;%%00010    if (titleEdit || subtitleEdit) {%%00010      if (titleEdit) {%%00010        var chartTitleText = knimeService.createMenuTextField(%%00010          'chartTitleText', _value.options.title, function () {%%00010            if (_value.options.title != this.value) {%%00010              _value.options.title = this.value;%%00010              updateTitles(true);%%00010            }%%00010          }, true);%%00010        knimeService.addMenuItem('Chart Title:', 'header', chartTitleText);%%00010      }%%00010      if (subtitleEdit) {%%00010        var chartSubtitleText = knimeService.createMenuTextField(%%00010          'chartSubtitleText', _value.options.subtitle,%%00010          function () {%%00010            if (_value.options.subtitle != this.value) {%%00010              _value.options.subtitle = this.value;%%00010              updateTitles(true);%%00010            }%%00010          }, true);%%00010        knimeService.addMenuItem('Chart Subtitle:', 'header', chartSubtitleText, null, knimeService.SMALL_ICON);%%00010      }%%00010    }%%00010%%00010    // x-Axis &amp; y-Axis Labels%%00010    var xAxisEdit = _representation.options.enableXAxisEdit;%%00010    var yAxisEdit = _representation.options.enableYAxisEdit;%%00010    if (xAxisEdit || yAxisEdit) {%%00010      knimeService.addMenuDivider();%%00010%%00010      if (xAxisEdit) {%%00010        var xAxisText = knimeService.createMenuTextField(%%00010          'xAxisText', _value.options.xAxisLabel,%%00010          function () {%%00010            if (_value.options.xAxisLabel != this.value) {%%00010              _value.options.xAxisLabel = this.value;%%00010              updateAxisLabels(true);%%00010            }%%00010          }, true);%%00010        knimeService.addMenuItem('X-axis label:', 'ellipsis-h', xAxisText);%%00010      }%%00010      if (yAxisEdit) {%%00010        var yAxisText = knimeService.createMenuTextField(%%00010          'yAxisText', _value.options.yAxisLabel,%%00010          function () {%%00010            if (_value.options.yAxisLabel != this.value) {%%00010              _value.options.yAxisLabel = this.value;%%00010              updateAxisLabels(true);%%00010            }%%00010          }, true);%%00010        knimeService.addMenuItem('Y-axis label:', 'ellipsis-v', yAxisText);%%00010      }%%00010    }%%00010%%00010    // Chart Type / Interpolation Method / Custom Color%%00010    var chartTypeChange = _representation.options.enableChartTypeChange;%%00010    var interpolationEdit = _representation.options.enableInterpolationMethodEdit;%%00010    if (chartTypeChange || interpolationEdit || customColorToggle) {%%00010      knimeService.addMenuDivider();%%00010%%00010      if (chartTypeChange) {%%00010        var chartTypes = Object.keys(stackStyleByType);%%00010        var chartTypeSelector =%%00010          knimeService.createMenuSelect('chartTypeSelector', _value.options.chartType, chartTypes, function () {%%00010            _value.options.chartType = this.options[this.selectedIndex].value;%%00010            drawChart();  // needs a redraw to avoid tooltip problem (AP-7068)%%00010          });%%00010        knimeService.addMenuItem('Chart Type:', 'area-chart', chartTypeSelector);%%00010      }%%00010%%00010      if (interpolationEdit) {%%00010        var interpolationMethods = ['basis', 'linear', 'step'];%%00010        var interpolationMethodSelector =%%00010          knimeService.createMenuSelect('interpolationMethodSelector', _value.options.interpolation, interpolationMethods, function () {%%00010            var changedToBasis = this.options[this.selectedIndex].value == 'basis' &amp;&amp; _value.options.interpolation != 'basis';%%00010            _value.options.interpolation = this.options[this.selectedIndex].value;%%00010            if (changedToBasis &amp;&amp; _value.options.interactiveGuideline) {%%00010              drawChart();%%00010            } else {%%00010              knimeService.clearWarningMessage(TOOLTIP_WARNING);%%00010              chart.interpolate(_value.options.interpolation);%%00010              chart.useInteractiveGuideline(_value.options.interpolation == 'basis' ? false : _value.options.interactiveGuideline);%%00010              chart.update();%%00010            }%%00010          });%%00010        // CHECK: Should we use line-chart here?%%00010        knimeService.addMenuItem('Interpolation:', 'bar-chart', interpolationMethodSelector);%%00010      }%%00010    }%%00010%%00010    // Legend, Interactive Guideline, Grid%%00010    var legendToggle = _representation.options.enableLegendToggle;%%00010    var interactiveGuidelineToggle = _representation.options.enableInteractiveGuidelineToggle;%%00010    var showGridToggle = _representation.options.showGridToggle;%%00010    if (legendToggle || interactiveGuidelineToggle || showGridToggle) {%%00010      knimeService.addMenuDivider();%%00010%%00010      if (legendToggle) {%%00010        var legendCheckbox = knimeService.createMenuCheckbox(%%00010          'legendCheckbox', _value.options.legend, function () {%%00010            _value.options.legend = this.checked;%%00010            toggleLegend();%%00010          });%%00010        knimeService.addMenuItem('Legend:', 'info-circle', legendCheckbox);%%00010      }%%00010%%00010      if (interactiveGuidelineToggle) {%%00010        var interactiveGuidelineCheckbox = knimeService.createMenuCheckbox(%%00010          'interactiveGuidelineCheckbox',%%00010          _value.options.interactiveGuideline,%%00010          function () {%%00010            _value.options.interactiveGuideline = this.checked;%%00010            drawChart();%%00010          });%%00010%%00010        knimeService.addMenuItem('Tooltip:', 'comment',%%00010          interactiveGuidelineCheckbox);%%00010      }%%00010%%00010      if (showGridToggle) {%%00010        var gridCheckbox = knimeService.createMenuCheckbox(%%00010          'gridCheckbox', _value.options.showGrid, function () {%%00010            _value.options.showGrid = this.checked;%%00010            toggleGrid();%%00010          });%%00010        knimeService.addMenuItem('Show Grid:', 'th', gridCheckbox);%%00010      }%%00010    }%%00010%%00010    // Filter event checkbox.%%00010    if (knimeService.isInteractivityAvailable()) {%%00010      knimeService.addMenuDivider();%%00010      var subFilIcon = knimeService.createStackedIcon('filter', 'angle-double-right', 'faded right sm', 'left bold');%%00010%%00010      var subFilCheckbox = knimeService.createMenuCheckbox(%%00010        'filterCheckbox', _value.options.subscribeFilter, function () {%%00010          _value.options.subscribeFilter = this.checked;%%00010          toggleFilter();%%00010        });%%00010      knimeService.addMenuItem('Subscribe to filter', subFilIcon, subFilCheckbox);%%00010    }%%00010  };%%00010%%00010  function setCssClasses() {%%00010    // axis%%00010    var axis = d3.selectAll('.nv-axis')%%00010      .classed('knime-axis', true);%%00010    d3.selectAll('.nv-x')%%00010      .classed('knime-x', true);%%00010    d3.selectAll('.nv-y')%%00010      .classed('knime-y', true);%%00010    d3.selectAll('.nv-axislabel')%%00010      .classed('knime-axis-label', true);%%00010    axis.selectAll('path.domain')%%00010      .classed('knime-axis-line', true);%%00010    var axisMaxMin = d3.selectAll('.nv-axisMaxMin')%%00010      .classed('knime-axis-max-min', true);%%00010    axisMaxMin.selectAll('text')%%00010      .classed('knime-tick-label', true);%%00010    var tick = axis.selectAll('.knime-axis .tick')%%00010      .classed('knime-tick', true);%%00010    tick.selectAll('text')%%00010      .classed('knime-tick-label', true);%%00010    tick.selectAll('line')%%00010      .classed('knime-tick-line', true);%%00010%%00010    // legend%%00010    d3.selectAll('.nv-legendWrap')%%00010      .classed('knime-legend', true);%%00010    d3.selectAll('.nv-legend-symbol')%%00010      .classed('knime-legend-symbol', true);%%00010    d3.selectAll('.nv-legend-text')%%00010      .classed('knime-legend-label', true);%%00010  }%%00010%%00010  function setTooltipCssClasses() {%%00010    // tooltip%%00010    var tooltip = d3.selectAll('.nvtooltip')%%00010      .classed('knime-tooltip', true);%%00010    tooltip.selectAll('.x-value')%%00010      .classed('knime-tooltip-caption', true)%%00010      .classed('knime-x', true);%%00010    tooltip.selectAll('.legend-color-guide')%%00010      .classed('knime-tooltip-color', true);%%00010    tooltip.selectAll('.key')%%00010      .classed('knime-tooltip-key', true);%%00010    tooltip.selectAll('.value')%%00010      .classed('knime-tooltip-value', true);%%00010  }%%00010%%00010  view.validate = function () {%%00010    return true;%%00010  }%%00010%%00010  view.getComponentValue = function () {%%00010    // Save disabled-state of the series from the chart if:%%00010    //   - it was saved in _value before%%00010    //   - some series are disabled%%00010%%00010    var container = d3.select(&quot;#svgContainer&quot;);%%00010    var disabled = container.selectAll('g .nv-series').data().map(function (o) { return !!o.disabled })%%00010%%00010    if ((&quot;disabled&quot; in _value.options) || disabled.some(Boolean)) {%%00010      _value.options.disabled = disabled;%%00010    }%%00010%%00010    return _value;%%00010  }%%00010%%00010  view.getSVG = function () {    %%00010    // correct faulty rect elements%%00010    d3.selectAll(&quot;rect&quot;).each(function () {%%00010      var rect = d3.select(this);%%00010      if (!rect.attr(&quot;width&quot;)) {%%00010        rect.attr(&quot;width&quot;, 0);%%00010      }%%00010      if (!rect.attr(&quot;height&quot;)) {%%00010        rect.attr(&quot;height&quot;, 0);%%00010      }%%00010    });%%00010    var svgElement = d3.select(&quot;svg&quot;)[0][0];%%00010%%00009knimeService.inlineSvgStyles(svgElement);%%00010%%00009// Return the SVG as a string.%%00010%%00009return (new XMLSerializer()).serializeToString(svgElement);%%00010  };%%00010%%00010  return view;%%00010%%00010}());"/>
</config>
<config key="cssCode">
<entry key="array-size" type="xint" value="0"/>
</config>
<config key="jsDependencies">
<entry key="numSettings" type="xint" value="4"/>
<config key="dependency_0">
<entry key="name" type="xstring" value="nvd3"/>
<entry key="path" type="xstring" value="js-lib/nvd3/1.8.4/nv.d3.min.js"/>
<entry key="usesDefine" type="xboolean" value="false"/>
<entry key="exports" type="xstring" value="nv"/>
<config key="dependencies">
<entry key="array-size" type="xint" value="1"/>
<entry key="0" type="xstring" value="D3_3.5.5"/>
</config>
<entry key="local" type="xboolean" value="true"/>
</config>
<config key="dependency_1">
<entry key="name" type="xstring" value="D3_3.5.5"/>
<entry key="path" type="xstring" value="js-lib/d3/d3.v3_5_5.min.js"/>
<entry key="usesDefine" type="xboolean" value="false"/>
<entry key="exports" type="xstring" isnull="true" value=""/>
<config key="dependencies">
<entry key="array-size" type="xint" value="0"/>
</config>
<entry key="local" type="xboolean" value="true"/>
</config>
<config key="dependency_2">
<entry key="name" type="xstring" value="moment"/>
<entry key="path" type="xstring" value="js-lib/moment/2_17/timezone/moment-timezone-with-data.min.js"/>
<entry key="usesDefine" type="xboolean" value="false"/>
<entry key="exports" type="xstring" value="moment"/>
<config key="dependencies">
<entry key="array-size" type="xint" value="1"/>
<entry key="0" type="xstring" value="moment_locales_2_17"/>
</config>
<entry key="local" type="xboolean" value="true"/>
</config>
<config key="dependency_3">
<entry key="name" type="xstring" value="moment_locales_2_17"/>
<entry key="path" type="xstring" value="js-lib/moment/2_17/locales/moment-with-locales.min.js"/>
<entry key="usesDefine" type="xboolean" value="false"/>
<entry key="exports" type="xstring" isnull="true" value=""/>
<config key="dependencies">
<entry key="array-size" type="xint" value="0"/>
</config>
<entry key="local" type="xboolean" value="true"/>
</config>
</config>
<config key="cssDependencies">
<entry key="array-size" type="xint" value="1"/>
<entry key="0" type="xstring" value="js-lib/nvd3/1.8.4/nv.d3.min.css"/>
</config>
<entry key="new" type="xboolean" value="false"/>
<entry key="inView" type="xboolean" value="true"/>
<config key="tableIds">
<entry key="array-size" type="xint" value="2"/>
<entry key="0" type="xstring" value="c8c44764-acf2-4a0a-b6a2-8eddb37e3218"/>
<entry key="1" type="xstring" isnull="true" value=""/>
</config>
<config key="variables">
<entry key="numSettings" type="xint" value="6"/>
<entry key="mapClass" type="xstring" value="string"/>
<entry key="key_0" type="xstring" value="#False"/>
<entry key="class_0" type="xstring" value="java.lang.String"/>
<entry key="value_0" type="xstring" value="11717"/>
<entry key="key_1" type="xstring" value="knime.workspace"/>
<entry key="class_1" type="xstring" value="java.lang.String"/>
<entry key="value_1" type="xstring" value="C:\Users\felix\Desktop\Google_Drive\IN\KNIME"/>
<entry key="key_2" type="xstring" value="Accuracy"/>
<entry key="class_2" type="xstring" value="java.lang.String"/>
<entry key="value_2" type="xstring" value="0.7043550666128381"/>
<entry key="key_3" type="xstring" value="#Correct"/>
<entry key="class_3" type="xstring" value="java.lang.String"/>
<entry key="value_3" type="xstring" value="27915"/>
<entry key="key_4" type="xstring" value="Error"/>
<entry key="class_4" type="xstring" value="java.lang.String"/>
<entry key="value_4" type="xstring" value="0.2956449333871619"/>
<entry key="key_5" type="xstring" value="Cohen's kappa"/>
<entry key="class_5" type="xstring" value="java.lang.String"/>
<entry key="value_5" type="xstring" value="0.11024667378615216"/>
</config>
<config key="binaryFiles">
<entry key="numSettings" type="xint" value="0"/>
<entry key="mapClass" type="xstring" value="string"/>
</config>
<config key="options">
<entry key="numSettings" type="xint" value="18"/>
<entry key="mapClass" type="xstring" value="object"/>
<entry key="key_0" type="xstring" value="displayFullscreenButton"/>
<entry key="class_0" type="xstring" value="java.lang.Boolean"/>
<entry key="value_0" type="xboolean" value="true"/>
<entry key="key_1" type="xstring" value="xAxisSort"/>
<entry key="class_1" type="xstring" value="java.lang.Boolean"/>
<entry key="value_1" type="xboolean" value="true"/>
<entry key="key_2" type="xstring" value="svg"/>
<entry key="class_2" type="xstring" value="org.knime.dynamic.js.SettingsModelSVGOptions$JSONSVGOptions"/>
<config key="value_2">
<entry key="width" type="xint" value="800"/>
<entry key="height" type="xint" value="600"/>
<entry key="fullscreen" type="xboolean" value="true"/>
</config>
<entry key="key_3" type="xstring" value="columns"/>
<entry key="class_3" type="xstring" value="[Ljava.lang.String;"/>
<config key="value_3">
<entry key="array-size" type="xint" value="1"/>
<entry key="0" type="xstring" value="Accuracy"/>
</config>
<entry key="key_4" type="xstring" value="enableTitleEdit"/>
<entry key="class_4" type="xstring" value="java.lang.Boolean"/>
<entry key="value_4" type="xboolean" value="true"/>
<entry key="key_5" type="xstring" value="xAxisFormatString"/>
<entry key="class_5" type="xstring" value="java.lang.String"/>
<entry key="value_5" type="xstring" value=",.2f"/>
<entry key="key_6" type="xstring" value="enableLegendToggle"/>
<entry key="class_6" type="xstring" value="java.lang.Boolean"/>
<entry key="value_6" type="xboolean" value="true"/>
<entry key="key_7" type="xstring" value="dateTimeFormats"/>
<entry key="class_7" type="xstring" value="org.knime.js.core.components.datetime.SettingsModelDateTimeOptions$JSONDateTimeOptions"/>
<config key="value_7">
<entry key="globalDateTimeLocale" type="xstring" value="en"/>
<entry key="globalDateFormat" type="xstring" value="YYYY-MM-DD"/>
<entry key="globalLocalDateFormat" type="xstring" value="YYYY-MM-DD"/>
<entry key="globalLocalDateTimeFormat" type="xstring" value="YYYY-MM-DD"/>
<entry key="globalLocalTimeFormat" type="xstring" value="HH:mm:ss"/>
<entry key="globalZonedDateTimeFormat" type="xstring" value="YYYY-MM-DD z"/>
<entry key="timezone" type="xstring" value="Europe/Paris"/>
</config>
<entry key="key_8" type="xstring" value="enableInterpolationMethodEdit"/>
<entry key="class_8" type="xstring" value="java.lang.Boolean"/>
<entry key="value_8" type="xboolean" value="true"/>
<entry key="key_9" type="xstring" value="showGridToggle"/>
<entry key="class_9" type="xstring" value="java.lang.Boolean"/>
<entry key="value_9" type="xboolean" value="true"/>
<entry key="key_10" type="xstring" value="enableChartTypeChange"/>
<entry key="class_10" type="xstring" value="java.lang.Boolean"/>
<entry key="value_10" type="xboolean" value="true"/>
<entry key="key_11" type="xstring" value="enableInteractiveGuidelineToggle"/>
<entry key="class_11" type="xstring" value="java.lang.Boolean"/>
<entry key="value_11" type="xboolean" value="true"/>
<entry key="key_12" type="xstring" value="xAxisColumn"/>
<entry key="class_12" type="xstring" value="java.lang.String"/>
<entry key="value_12" type="xstring" value="nombre"/>
<entry key="key_13" type="xstring" value="yAxisFormatString"/>
<entry key="class_13" type="xstring" value="java.lang.String"/>
<entry key="value_13" type="xstring" value=",.2f"/>
<entry key="key_14" type="xstring" value="enableXAxisEdit"/>
<entry key="class_14" type="xstring" value="java.lang.Boolean"/>
<entry key="value_14" type="xboolean" value="true"/>
<entry key="key_15" type="xstring" value="enableViewControls"/>
<entry key="class_15" type="xstring" value="java.lang.Boolean"/>
<entry key="value_15" type="xboolean" value="true"/>
<entry key="key_16" type="xstring" value="enableSubtitleEdit"/>
<entry key="class_16" type="xstring" value="java.lang.Boolean"/>
<entry key="value_16" type="xboolean" value="true"/>
<entry key="key_17" type="xstring" value="enableYAxisEdit"/>
<entry key="class_17" type="xstring" value="java.lang.Boolean"/>
<entry key="value_17" type="xboolean" value="true"/>
</config>
<config key="inObjects">
<entry key="numSettings" type="xint" value="2"/>
<config key="inObject_0">
<entry key="knimeDataTableJSON" type="xstring" value="{&quot;@class&quot;:&quot;org.knime.js.core.JSONDataTable&quot;,&quot;id&quot;:&quot;c8c44764-acf2-4a0a-b6a2-8eddb37e3218&quot;,&quot;extensions&quot;:null,&quot;rows&quot;:[{&quot;data&quot;:[&quot;Gradient Bossted&quot;,0.77908384623146],&quot;rowKey&quot;:&quot;Gradient Boosted&quot;},{&quot;data&quot;:[&quot;K-NN&quot;,0.7698825530801191],&quot;rowKey&quot;:&quot;K-NN&quot;},{&quot;data&quot;:[&quot;Naive Bayes&quot;,0.5636918575320351],&quot;rowKey&quot;:&quot;Naive Bayes&quot;},{&quot;data&quot;:[&quot;Random Forest&quot;,0.7763091514478861],&quot;rowKey&quot;:&quot;Random Forest&quot;},{&quot;data&quot;:[&quot;Red Neuronal&quot;,0.7773938048632832],&quot;rowKey&quot;:&quot;Red Neuronal&quot;},{&quot;data&quot;:[&quot;Tree Decision&quot;,0.7043550666128381],&quot;rowKey&quot;:&quot;Tree Decision&quot;}],&quot;spec&quot;:{&quot;@class&quot;:&quot;org.knime.js.core.JSONDataTableSpec&quot;,&quot;numColumns&quot;:2,&quot;numRows&quot;:6,&quot;colNames&quot;:[&quot;nombre&quot;,&quot;Accuracy&quot;],&quot;colTypes&quot;:[&quot;string&quot;,&quot;number&quot;],&quot;numExtensions&quot;:0,&quot;maxValues&quot;:[&quot;Tree Decision&quot;,0.77908384623146],&quot;minValues&quot;:[&quot;Gradient Bossted&quot;,0.5636918575320351],&quot;rowSizeValues&quot;:null,&quot;colorModels&quot;:[],&quot;knimeTypes&quot;:[&quot;String&quot;,&quot;Number (double)&quot;],&quot;possibleValues&quot;:[[&quot;Gradient Bossted&quot;,&quot;K-NN&quot;,&quot;Naive Bayes&quot;,&quot;Random Forest&quot;,&quot;Red Neuronal&quot;,&quot;Tree Decision&quot;],null],&quot;rowColorValues&quot;:[&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;],&quot;containsMissingValues&quot;:[false,false],&quot;filterIds&quot;:[null,null],&quot;extensionTypes&quot;:[],&quot;extensionNames&quot;:[]},&quot;dataHash&quot;:null}"/>
</config>
<config key="inObject_1">
<entry key="jsonValue" type="xstring" isnull="true" value=""/>
</config>
</config>
<entry key="warnMessage" type="xstring" value=""/>
<entry key="errorMessage" type="xstring" value=""/>
</config>
